<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>vicar.vicarlabel &mdash; vicar  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            vicar
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module.html"><code class="docutils literal notranslate"><span class="pre">vicar</span></code> Module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">vicar</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">vicar.vicarlabel</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for vicar.vicarlabel</h1><div class="highlight"><pre>
<span></span><span class="c1">##########################################################################################</span>
<span class="c1"># vicar/vicarlabel.py</span>
<span class="c1">##########################################################################################</span>
<span class="sd">&quot;&quot;&quot;Class to support accessing, reading, and modifying VICAR labels.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">pyparsing</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">vicar._LABEL_GRAMMAR</span> <span class="kn">import</span> <span class="n">_LABEL_GRAMMAR</span>

<span class="n">_NAME</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[A-Z][A-Z0-9_]*$&#39;</span><span class="p">)</span>
<span class="n">_LBLSIZE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;LBLSIZE *= *(\d+)&#39;</span><span class="p">)</span>

<span class="n">_ValueFormat</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_ValueFormat&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;fmt&#39;</span><span class="p">,</span> <span class="s1">&#39;name_blanks&#39;</span><span class="p">,</span> <span class="s1">&#39;val_blanks&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;sep_blanks&#39;</span><span class="p">,</span> <span class="s1">&#39;listfmts&#39;</span><span class="p">])</span>
<span class="n">_ListFormat</span>  <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_ListFormat&#39;</span><span class="p">,</span>  <span class="p">[</span><span class="s1">&#39;fmt&#39;</span><span class="p">,</span> <span class="s1">&#39;blanks_before&#39;</span><span class="p">,</span> <span class="s1">&#39;blanks_after&#39;</span><span class="p">])</span>

<span class="c1"># [(sys.byteorder,sys.platform)] -&gt; HOST</span>
<span class="n">_HOST_DICT</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;big&#39;</span>   <span class="p">,</span> <span class="s1">&#39;sunos3&#39;</span><span class="p">):</span> <span class="s1">&#39;SUN-3&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;big&#39;</span>   <span class="p">,</span> <span class="s1">&#39;sunos4&#39;</span><span class="p">):</span> <span class="s1">&#39;SUN-4&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;big&#39;</span>   <span class="p">,</span> <span class="s1">&#39;sunos5&#39;</span><span class="p">):</span> <span class="s1">&#39;SUN-SOLR&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;sunos5&#39;</span><span class="p">):</span> <span class="s1">&#39;X86-LINUX&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;big&#39;</span>   <span class="p">,</span> <span class="s1">&#39;darwin&#39;</span><span class="p">):</span> <span class="s1">&#39;MAC-OSX&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;darwin&#39;</span><span class="p">):</span> <span class="s1">&#39;MAC-OSX&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;linux2&#39;</span><span class="p">):</span> <span class="s1">&#39;X86-LINUX&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;linux3&#39;</span><span class="p">):</span> <span class="s1">&#39;X86-LINUX&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;linux&#39;</span> <span class="p">):</span> <span class="s1">&#39;X86-LINUX&#39;</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;win32&#39;</span> <span class="p">):</span> <span class="s1">&#39;WIN-XP&#39;</span>     <span class="p">}</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">_HOST</span> <span class="o">=</span> <span class="n">_HOST_DICT</span><span class="p">[(</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">)]</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>                <span class="c1"># pragma: no cover</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;linux&#39;</span><span class="p">):</span>
        <span class="n">_HOST</span> <span class="o">=</span> <span class="s1">&#39;X86-LINUX&#39;</span>     <span class="c1"># could be &quot;linux4&quot; I guess</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_HOST</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

<span class="c1"># [sys.byteorder] -&gt; INTFMT, REALFMT</span>
<span class="n">_INTFMT_DICT</span>  <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;little&#39;</span><span class="p">:</span> <span class="s1">&#39;LOW&#39;</span>  <span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span> <span class="s1">&#39;HIGH&#39;</span><span class="p">}</span>
<span class="n">_REALFMT_DICT</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;little&#39;</span><span class="p">:</span> <span class="s1">&#39;RIEEE&#39;</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span> <span class="s1">&#39;IEEE&#39;</span><span class="p">}</span>

<span class="c1"># Required keywords, default values</span>
<span class="n">_REQUIRED</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;LBLSIZE&#39;</span> <span class="p">,</span> <span class="mi">0</span><span class="p">,</span>     <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;FORMAT&#39;</span>  <span class="p">,</span> <span class="s1">&#39;BYTE&#39;</span> <span class="p">),</span>     <span class="c1"># Guess</span>
             <span class="p">(</span><span class="s1">&#39;TYPE&#39;</span>    <span class="p">,</span> <span class="s1">&#39;IMAGE&#39;</span><span class="p">),</span>     <span class="c1"># Guess</span>
             <span class="p">(</span><span class="s1">&#39;BUFSIZ&#39;</span>  <span class="p">,</span> <span class="mi">20480</span>  <span class="p">),</span>     <span class="c1"># Always ignored</span>
             <span class="p">(</span><span class="s1">&#39;DIM&#39;</span>     <span class="p">,</span> <span class="mi">3</span>      <span class="p">),</span>     <span class="c1"># Always</span>
             <span class="p">(</span><span class="s1">&#39;EOL&#39;</span>     <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;RECSIZE&#39;</span> <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;ORG&#39;</span>     <span class="p">,</span> <span class="s1">&#39;BSQ&#39;</span>  <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;NL&#39;</span>      <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;NS&#39;</span>      <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;NB&#39;</span>      <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;N1&#39;</span>      <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;N2&#39;</span>      <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;N3&#39;</span>      <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;N4&#39;</span>      <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>     <span class="c1"># Always</span>
             <span class="p">(</span><span class="s1">&#39;NBB&#39;</span>     <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;NLB&#39;</span>     <span class="p">,</span> <span class="mi">0</span>      <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;HOST&#39;</span>    <span class="p">,</span> <span class="n">_HOST</span>  <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;INTFMT&#39;</span>  <span class="p">,</span> <span class="n">_INTFMT_DICT</span> <span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span><span class="p">]),</span>
             <span class="p">(</span><span class="s1">&#39;REALFMT&#39;</span> <span class="p">,</span> <span class="n">_REALFMT_DICT</span><span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span><span class="p">]),</span>
             <span class="p">(</span><span class="s1">&#39;BHOST&#39;</span>   <span class="p">,</span> <span class="n">_HOST</span>  <span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;BINTFMT&#39;</span> <span class="p">,</span> <span class="n">_INTFMT_DICT</span> <span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span><span class="p">]),</span>
             <span class="p">(</span><span class="s1">&#39;BREALFMT&#39;</span><span class="p">,</span> <span class="n">_REALFMT_DICT</span><span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span><span class="p">]),</span>
             <span class="p">(</span><span class="s1">&#39;BLTYPE&#39;</span>  <span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),]</span>
<span class="n">_REQUIRED_NAMES</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_REQUIRED</span><span class="p">])</span>

<span class="n">_LBLSIZE_WIDTH</span> <span class="o">=</span> <span class="mi">16</span>     <span class="c1"># fixed space between &quot;LBLSIZE=&quot; and the next parameter name</span>

<span class="n">_ENUMERATED_VALUES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;FORMAT&#39;</span>  <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;BYTE&#39;</span><span class="p">,</span> <span class="s1">&#39;HALF&#39;</span><span class="p">,</span> <span class="s1">&#39;FULL&#39;</span><span class="p">,</span> <span class="s1">&#39;REAL&#39;</span><span class="p">,</span> <span class="s1">&#39;DOUB&#39;</span><span class="p">,</span> <span class="s1">&#39;COMP&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;WORD&#39;</span><span class="p">,</span> <span class="s1">&#39;LONG&#39;</span><span class="p">,</span> <span class="s1">&#39;COMPLEX&#39;</span><span class="p">},</span>
    <span class="s1">&#39;ORG&#39;</span>     <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;BSQ&#39;</span><span class="p">,</span> <span class="s1">&#39;BIL&#39;</span><span class="p">,</span> <span class="s1">&#39;BIP&#39;</span><span class="p">},</span>
    <span class="s1">&#39;INTFMT&#39;</span>  <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;HIGH&#39;</span><span class="p">,</span> <span class="s1">&#39;LOW&#39;</span><span class="p">},</span>
    <span class="s1">&#39;REALFMT&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;IEEE&#39;</span><span class="p">,</span> <span class="s1">&#39;RIEEE&#39;</span><span class="p">,</span> <span class="s1">&#39;VAX&#39;</span><span class="p">},</span>
    <span class="s1">&#39;BINTFMT&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;HIGH&#39;</span><span class="p">,</span> <span class="s1">&#39;LOW&#39;</span><span class="p">},</span>
    <span class="s1">&#39;BREALFMT&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;IEEE&#39;</span><span class="p">,</span> <span class="s1">&#39;RIEEE&#39;</span><span class="p">,</span> <span class="s1">&#39;VAX&#39;</span><span class="p">},</span>
    <span class="s1">&#39;DIM&#39;</span>     <span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;EOL&#39;</span>     <span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;N4&#39;</span>      <span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
<span class="p">}</span>

<span class="n">_REQUIRED_INTS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">,</span> <span class="s1">&#39;RECSIZE&#39;</span><span class="p">,</span> <span class="s1">&#39;NL&#39;</span><span class="p">,</span> <span class="s1">&#39;NS&#39;</span><span class="p">,</span> <span class="s1">&#39;NB&#39;</span><span class="p">,</span> <span class="s1">&#39;N1&#39;</span><span class="p">,</span> <span class="s1">&#39;N2&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;NBB&#39;</span><span class="p">,</span> <span class="s1">&#39;NLB&#39;</span><span class="p">}</span>


<div class="viewcode-block" id="VicarError">
<a class="viewcode-back" href="../../module.html#vicar.VicarError">[docs]</a>
<span class="k">class</span> <span class="nc">VicarError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ValueError subclass for violations of the VICAR format standard.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>



<div class="viewcode-block" id="VicarLabel">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel">[docs]</a>
<span class="k">class</span> <span class="nc">VicarLabel</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to support accessing, reading, modifying, and writing VICAR labels.</span>

<span class="sd">    **Properties:**</span>

<span class="sd">        * filepath: The file path associated with this VicarLabel.</span>

<span class="sd">    **Core Methods:**</span>

<span class="sd">        * append: Append one or more parameters to the end of this label.</span>
<span class="sd">        * arg: The index of a parameter name within this label.</span>
<span class="sd">        * args: Iterator over the numeric indices of the parameters in this label.</span>
<span class="sd">        * as_string: A string representing all or part of this label.</span>
<span class="sd">        * copy: An independent (deep) copy of this VicarLabel.</span>
<span class="sd">        * export: Returns a label parameter string of the form NAME=VALUE.</span>
<span class="sd">        * from_file: Construct a VicarLabel object from the content of a VICAR data file.</span>
<span class="sd">        * get: Retrieve a label parameter value or return a default.</span>
<span class="sd">        * insert: Insert one or more parameters into this label.</span>
<span class="sd">        * items: Iterator over the (name, value) tuples in this label.</span>
<span class="sd">        * keys: Iterator over the parameter names in this label as unique keys.</span>
<span class="sd">        * name_value_str: Returns a label parameter string of the form NAME=VALUE.</span>
<span class="sd">        * names: Iterator over the parameter names in this label.</span>
<span class="sd">        * read_label: Read the label string(s) from a file.</span>
<span class="sd">        * reorder: Reorder the parameters in this label.</span>
<span class="sd">        * value_str: Formats a label parameter value.</span>
<span class="sd">        * values: Iterator over the parameter values in this label.</span>
<span class="sd">        * write_label: Write this label into a data file, replacing an existing label.</span>

<span class="sd">    **Python Syntax Support Methods:**</span>

<span class="sd">        * __contains__: Enables &quot;name in label&quot; syntax.</span>
<span class="sd">        * __delitem__: Enables &quot;del label[name]&quot; syntax.</span>
<span class="sd">        * __eq__: Enables &quot;a == b&quot;, the test of whether two labels are equal.</span>
<span class="sd">        * __getitem__: Enables &quot;label[name]&quot; dictionary-like syntax.</span>
<span class="sd">        * __iter__: Enables &quot;for key in label:&quot; syntax.</span>
<span class="sd">        * __len__: Enables &quot;len(label)&quot;, the number of parameters in the given VicarLabel.</span>
<span class="sd">        * __repr__: Enables &quot;repr(label)&quot;, similar to the &quot;str(label)&quot;, but with the class</span>
<span class="sd">          name included.</span>
<span class="sd">        * __setitem__: Enables &quot;label[name] = value&quot; dictionary-like syntax.</span>
<span class="sd">        * __str__: Enables &quot;str(label)&quot;, returning a string representing the content of a</span>
<span class="sd">          label.</span>

<span class="sd">    **Notes About Dictionary Keys:**</span>

<span class="sd">        When using dictionary-like syntax to reference a parameter in a VICAR label, a</span>
<span class="sd">        rich set of options are available. For example, if `label` is a VicarLabel object,</span>
<span class="sd">        then:</span>

<span class="sd">            * &quot;label[n]&quot; where `n` is an integer refers to the &quot;nth&quot; parameter in the</span>
<span class="sd">              label. `n` can be positive or negative.</span>
<span class="sd">            * &quot;label[name]&quot; where `name` is a string refers to the first occurrence in the</span>
<span class="sd">              label of a parameter with this name.</span>
<span class="sd">            * &quot;label[name,n]&quot; refers to the &quot;nth&quot; occurrence in the label of a parameter</span>
<span class="sd">              with this name. `n` can be positive or negative.</span>
<span class="sd">            * &quot;label[name, after]&quot; where both items are strings refers to the first</span>
<span class="sd">              occurrence of parameter `name` after the first occurrence of parameter</span>
<span class="sd">              `after` and before the second occurrence of `after`.</span>
<span class="sd">            * &quot;label[name, after, value]&quot; refers to the first occurrence of parameter</span>
<span class="sd">              `name` after the first location where `after` equals `value` and before the</span>
<span class="sd">              next occurrence of `after`.</span>

<span class="sd">        The last two options make it easy to reference a VICAR label parameter that is</span>
<span class="sd">        repeated. For example, &quot;label[&#39;DAT_TIM&#39;, &#39;TASK&#39;, &#39;COPY&#39;]&quot; uniquely identifies the</span>
<span class="sd">        occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when there might be other</span>
<span class="sd">        &quot;TASK&quot; sections of the label containing other values of &quot;DAT_TIM&quot;.</span>

<span class="sd">        Append a &quot;+&quot; to `name` to expand upon the function&#39;s behavior. With &quot;get&quot;</span>
<span class="sd">        operations, a list is returned identifying all of the occurrences of the selected</span>
<span class="sd">        name rather than just the first or &quot;nth&quot;. With &quot;set&quot; operations, a new occurrence</span>
<span class="sd">        of `name` is inserted into the label even if the a parameter of the given name is</span>
<span class="sd">        already present.</span>

<span class="sd">    **Notes About VICAR Label Formatting Hints:**</span>

<span class="sd">        Formatting hints can be included wherever a VICAR parameter value is specified.</span>
<span class="sd">        When defining label parameters using a list of tuples, use (name, value, hints...)</span>
<span class="sd">        instead of (name, value). Elsewhere, simply replace the value by a tuple (value,</span>
<span class="sd">        hints...).</span>

<span class="sd">        Hints can be specified using up to four items:</span>

<span class="sd">            ([`format`][[[, `name_blanks`], `val_blanks`], `sep_blanks`])</span>

<span class="sd">        where:</span>

<span class="sd">            * `format` is a format string, e.g., &quot;%+7d&quot; or &quot;%7.3f&quot;.</span>
<span class="sd">            * `name_blanks` is the number of blank characters after the name and before</span>
<span class="sd">              the equal sign; zero by default.</span>
<span class="sd">            * `val_blanks` is the number of blank characters after the equal sign and</span>
<span class="sd">              before the value; zero by default.</span>
<span class="sd">            * `sep_blanks` is the number of blanks after the value and before the next</span>
<span class="sd">              label parameter or the label&#39;s end; two by default.</span>

<span class="sd">        Note the use of square brackets in the tuple expression above. If the first hint</span>
<span class="sd">        value is a string, it is interpreted as `format`; otherwise, the `format` is</span>
<span class="sd">        unspecified. After the optional format, values are interpreted as numbers of</span>
<span class="sd">        blanks. If only one int is provided, it defines `sep_blanks`, with `val_blanks`</span>
<span class="sd">        and `name_blanks` set to zero. If two trailing ints are provided, they define</span>
<span class="sd">        `val_blanks` and `sep_blanks`, with `name_blanks` set to zero.</span>

<span class="sd">        For example, if the name is &quot;TEXP&quot; and the value is 1.5, this is how hint values</span>
<span class="sd">        are interpreted::</span>

<span class="sd">                &lt;no hints&gt;        = (&quot;&quot;, 0, 0, 0)     -&gt; &quot;TEXP=1.5  &quot;</span>
<span class="sd">                &quot;%.3f&quot;            = (&quot;%.3f&quot;, 0, 0, 0) -&gt; &quot;TEXP=1.500  &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 4)       = (&quot;%.3f&quot;, 0, 0, 4) -&gt; &quot;TEXP=1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 1, 4)    = (&quot;%.3f&quot;, 0, 1, 4) -&gt; &quot;TEXP= 1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 2, 1, 4) = (&quot;%.3f&quot;, 2, 1, 4) -&gt; &quot;TEXP  = 1.500    &quot;</span>
<span class="sd">                4                 = (&quot;&quot;, 0, 0, 4)     -&gt; &quot;TEXP=1.5    &quot;</span>
<span class="sd">                (1, 4)            = (&quot;&quot;, 0, 1, 4)     -&gt; &quot;TEXP= 1.5    &quot;</span>
<span class="sd">                (2, 1, 4)         = (&quot;&quot;, 2, 1, 4)     -&gt; &quot;TEXP  = 1.5    &quot;</span>

<span class="sd">        When the parameter value is a list, it is also possible to embed formatting</span>
<span class="sd">        information on an item by item basis. Replace any item value by a tuple:</span>

<span class="sd">            (`item`[, `format`][[, `blanks_before`], `blanks_after`])</span>

<span class="sd">        where:</span>

<span class="sd">            * `format` is a format string, e.g., &quot;%+07d&quot;, &quot;%12.3e&quot; or &quot;%.4f&quot;.</span>
<span class="sd">            * `blanks_before` is the number of blanks before the value, after the left</span>
<span class="sd">              parenthesis or comma; zero is the default.</span>
<span class="sd">            * `blanks_after` is the number of blanks after the value and before the next</span>
<span class="sd">              next comma or the right parenthesis; zero is the default.</span>

<span class="sd">        Here are some examples of a list with embedded formatting for a parameter named</span>
<span class="sd">        &quot;XY&quot; with a value [7,6]::</span>

<span class="sd">            [(7, &quot;%+02d&quot;), 6]       = [(7, &quot;%+02d&quot;, 0, 0), 6] -&gt; &quot;XY=[+07, 6]  &quot;</span>
<span class="sd">            [(7, 2), 6]             = [(7, &quot;&quot;, 0, 2), 6]      -&gt; &quot;XY=[7  , 6]  &quot;</span>
<span class="sd">            [(7, 1, 2), 6])         = [(7, &quot;&quot;, 1, 2), 6]      -&gt; &quot;XY=[ 7  , 6]  &quot;</span>
<span class="sd">            [(7, &quot;%02d&quot;, 2), 6])    = [(7, &quot;%02d&quot;, 0, 2), 6]  -&gt; &quot;XY=[07  , 6]  &quot;</span>
<span class="sd">            [(7, &quot;%02d&quot;, 1, 2), 6]) = [(7, &quot;%02d&quot;, 1, 2), 6]  -&gt; &quot;XY=[ 07  , 6]  &quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="VicarLabel.__init__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor for a VicarLabel.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            source (file, pathlib.Path, str, None, dict, or list):</span>
<span class="sd">                A representation of a VICAR label:</span>

<span class="sd">                * *file*: The label string is read from the given, open file.</span>
<span class="sd">                * *pathlib.Path*: The label string is read from the referenced file.</span>
<span class="sd">                * *str*: First, a check is performed to see if it is path to an existing</span>
<span class="sd">                  file. If so, the label is read from that file; otherwise, the string is</span>
<span class="sd">                  itself interpreted as a VICAR label string.</span>
<span class="sd">                * *None*: The returned VicarLabel only contains the required parameters</span>
<span class="sd">                  with their default values.</span>
<span class="sd">                * *dict*: The label parameters are the names of the dictionary keys, given</span>
<span class="sd">                  in the order they were entered into the dictionary. Each dictionary</span>
<span class="sd">                  value is either the VICAR parameter value or a tuple(value, formatting</span>
<span class="sd">                  hints).</span>
<span class="sd">                * *list*: The label is derived from the given sequence of (name, value) or</span>
<span class="sd">                  (name, value, formatting hints) tuples.</span>

<span class="sd">                See ``Notes`` for details about formatting hints.</span>

<span class="sd">            strict (bool, optional):</span>
<span class="sd">                True (the default) to require strict conformance to the VICAR standard;</span>
<span class="sd">                False for a looser version of the standard. The standard is described</span>
<span class="sd">                here:</span>

<span class="sd">                    https://pds-rings.seti.org/help/VICAR_file_fmt.pdf</span>

<span class="sd">                When `strict` is False:</span>

<span class="sd">                    * names can exceed 32 characters and contain lower case letters.</span>
<span class="sd">                    * string values need not be pure 7-bit ASCII.</span>
<span class="sd">                    * lists can contain a mixture of types.</span>
<span class="sd">                    * lists can be empty.</span>

<span class="sd">        Raises:</span>
<span class="sd">            OSError: If the source is given as a file path that cannot be read.</span>

<span class="sd">            TypeError: If the source is an unrecognized type or contains an unrecognized</span>
<span class="sd">                type.</span>

<span class="sd">            VicarError: If the source violates the VICAR standard or a required VICAR</span>
<span class="sd">                parameter has an invalid value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Formatting hints can be included wherever a VICAR parameter value is</span>
<span class="sd">            specified. When defining label parameters using a list of tuples, use (name,</span>
<span class="sd">            value, hints...) instead of (name, value). Elsewhere, simply replace the value</span>
<span class="sd">            by a tuple (value, hints...).</span>

<span class="sd">            Hints can be specified using up to four items:</span>

<span class="sd">                ([`format`][[[, `name_blanks`], `val_blanks`], `sep_blanks`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+7d&quot; or &quot;%7.3f&quot;.</span>
<span class="sd">                * `name_blanks` is the number of blank characters after the name and</span>
<span class="sd">                  before the equal sign; zero by default.</span>
<span class="sd">                * `val_blanks` is the number of blank characters after the equal sign and</span>
<span class="sd">                  before the value; zero by default.</span>
<span class="sd">                * `sep_blanks` is the number of blanks after the value and before the next</span>
<span class="sd">                  label parameter or the label&#39;s end; two by default.</span>

<span class="sd">            Note the use of square brackets in the tuple expression above. If the first</span>
<span class="sd">            hint value is a string, it is interpreted as `format`; otherwise, the `format`</span>
<span class="sd">            is unspecified. After the optional format, values are interpreted as numbers</span>
<span class="sd">            of blanks. If only one int is provided, it defines `sep_blanks`, with</span>
<span class="sd">            `val_blanks` and `name_blanks` set to zero. If two trailing ints are provided,</span>
<span class="sd">            they define `val_blanks` and `sep_blanks`, with `name_blanks` set to zero.</span>

<span class="sd">            For example, if the name is &quot;TEXP&quot; and the value is 1.5, this is how hint</span>
<span class="sd">            values are interpreted::</span>

<span class="sd">                &lt;no hints&gt;        = (&quot;&quot;, 0, 0, 0)     -&gt; &quot;TEXP=1.5  &quot;</span>
<span class="sd">                &quot;%.3f&quot;            = (&quot;%.3f&quot;, 0, 0, 0) -&gt; &quot;TEXP=1.500  &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 4)       = (&quot;%.3f&quot;, 0, 0, 4) -&gt; &quot;TEXP=1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 1, 4)    = (&quot;%.3f&quot;, 0, 1, 4) -&gt; &quot;TEXP= 1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 2, 1, 4) = (&quot;%.3f&quot;, 2, 1, 4) -&gt; &quot;TEXP  = 1.500    &quot;</span>
<span class="sd">                4                 = (&quot;&quot;, 0, 0, 4)     -&gt; &quot;TEXP=1.5    &quot;</span>
<span class="sd">                (1, 4)            = (&quot;&quot;, 0, 1, 4)     -&gt; &quot;TEXP= 1.5    &quot;</span>
<span class="sd">                (2, 1, 4)         = (&quot;&quot;, 2, 1, 4)     -&gt; &quot;TEXP  = 1.5    &quot;</span>

<span class="sd">            When the parameter value is a list, it is also possible to embed formatting</span>
<span class="sd">            information on an item by item basis. Replace any item value by a tuple:</span>

<span class="sd">                (`item`[, `format`][[, `blanks_before`], `blanks_after`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+07d&quot;, &quot;%12.3e&quot; or &quot;%.4f&quot;.</span>
<span class="sd">                * `blanks_before` is the number of blanks before the value, after the left</span>
<span class="sd">                  parenthesis or comma; zero is the default.</span>
<span class="sd">                * `blanks_after` is the number of blanks after the value and before the</span>
<span class="sd">                  next comma or the right parenthesis; zero is the default.</span>

<span class="sd">            Here are some examples of a list with embedded formatting for a parameter</span>
<span class="sd">            named &quot;XY&quot; with a value [7,6]::</span>

<span class="sd">                [(7, &quot;%+02d&quot;), 6]       = [(7, &quot;%+02d&quot;, 0, 0), 6] -&gt; &quot;XY=[+07, 6]  &quot;</span>
<span class="sd">                [(7, 2), 6]             = [(7, &quot;&quot;, 0, 2), 6]      -&gt; &quot;XY=[7  , 6]  &quot;</span>
<span class="sd">                [(7, 1, 2), 6])         = [(7, &quot;&quot;, 1, 2), 6]      -&gt; &quot;XY=[ 7  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 2), 6])    = [(7, &quot;%02d&quot;, 0, 2), 6]  -&gt; &quot;XY=[07  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 1, 2), 6]) = [(7, &quot;%02d&quot;, 1, 2), 6]  -&gt; &quot;XY=[ 07  , 6]  &quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_strict</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">strict</span><span class="p">)</span>

        <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_source</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                   <span class="n">fileio</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel._update">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._update">[docs]</a>
    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method to define or re-define the label&#39;s content.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            names (list[str]): List of names, already validated.</span>

<span class="sd">            vals (list): List of values, already validated.</span>

<span class="sd">            fmts (list[_ValueFormat or None]): List of formatting hints, validated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span> <span class="o">=</span> <span class="n">fmts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_update</span> <span class="o">=</span> <span class="kc">True</span>      <span class="c1"># defer indexing during updates</span></div>


<div class="viewcode-block" id="VicarLabel._finish_update">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._finish_update">[docs]</a>
    <span class="k">def</span> <span class="nf">_finish_update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method to finish defining or re-defining the label&#39;s content.</span>

<span class="sd">        This must be called before any operation on the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_update</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>

        <span class="c1"># Dictionary keyed by name, returning list of indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Create ordered list of name or (name, occurrence) if name is not unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>

        <span class="c1"># Augment list with (name, occurrence) for duplicates</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">occs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">occs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unique_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">occs</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_waiting_to_update</span> <span class="o">=</span> <span class="kc">False</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># Properties</span>
    <span class="c1">######################################################################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The file path associated with this VicarLabel.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pathlib.Path or None:</span>
<span class="sd">                The Path if this object is associated with a file; None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span>

    <span class="nd">@filepath</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the file path associated with this VicarLabel.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            value (pathlib.Path or None):</span>
<span class="sd">                The Path to the file associated with this object; None if this object is</span>
<span class="sd">                not associated with a file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">######################################################################################</span>
    <span class="c1"># Support for the Standard Python API</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel.copy">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An independent (deep) copy of this VicarLabel.</span>

<span class="sd">        Returns:</span>
<span class="sd">            VicarLabel: The copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">label</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="p">[],</span> <span class="n">strict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_strict</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">_filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">]</span>  <span class="c1"># new lists</span>
        <span class="n">label</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">),</span> <span class="n">vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">label</span></div>


<div class="viewcode-block" id="VicarLabel.__len__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of keywords in the VICAR label.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of keywords.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span></div>


<div class="viewcode-block" id="VicarLabel.__eq__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__eq__">[docs]</a>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;VicarLabels are equal if they have the same parameter names in the same order.</span>
<span class="sd">        Formatting and filepath are ignored.</span>

<span class="sd">        VicarLabels are equal if their parameters and values are all the same; formatting</span>
<span class="sd">        hints need not be the same.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            other (VicarLabel): Second VicarLabel to compare with this.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the names and values are equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VicarLabel</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_names</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span></div>


<div class="viewcode-block" id="VicarLabel.__str__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">()</span></div>


<div class="viewcode-block" id="VicarLabel.__repr__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__repr__">[docs]</a>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;VicarLabel(&quot;&quot;&quot;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;&quot;&quot;)&#39;</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># Validation Utililties</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel._interpret_source">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._interpret_source">[docs]</a>
    <span class="k">def</span> <span class="nf">_interpret_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fileio</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpret and validate a source object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            source (file, pathlib.Path, str, None, dict, list, or tuple):</span>
<span class="sd">                A representation of VICAR label content:</span>

<span class="sd">                * *file*: The label string is read from the given, open file.</span>
<span class="sd">                * *pathlib.Path*: The label string is read from the referenced file.</span>
<span class="sd">                * *str*: First, a check is performed to see if it is path to an existing</span>
<span class="sd">                  file. If so, the label is read from that file; otherwise, the string is</span>
<span class="sd">                  itself interpreted as a VICAR label string.</span>
<span class="sd">                * *None*: The returned VicarLabel only contains the required parameters</span>
<span class="sd">                  with their default values.</span>
<span class="sd">                * *dict*: The label parameters are the names of the dictionary keys, given</span>
<span class="sd">                  in the order they were entered into the dictionary. Each dictionary</span>
<span class="sd">                  value is either the VICAR parameter value or a tuple(value, formatting</span>
<span class="sd">                  hints).</span>
<span class="sd">                * *list*: The label is derived from the given sequence of (name, value) or</span>
<span class="sd">                  (name, value, formatting hints) tuples.</span>
<span class="sd">                * *tuple*: A single parameter defined by (name, value) or (name, value,</span>
<span class="sd">                  formatting hints).</span>

<span class="sd">                See ``Notes`` for details about formatting hints.</span>

<span class="sd">            required (bool, optional):</span>
<span class="sd">                True to insert any required VICAR parameters that are missing.</span>

<span class="sd">            fileio (bool, optional):</span>
<span class="sd">                True to allow the source to be read from a file, file path string, or</span>
<span class="sd">                pathlib.Path object. In this case, the file path is returned in addition</span>
<span class="sd">                to the lists.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list, list, list[, pathlib.Path or None]): A tuple containing:</span>

<span class="sd">            * list[str]: List of names.</span>
<span class="sd">            * list[int, float, str, or list]: List of values.</span>
<span class="sd">            * list[_ValueFormat or None]: List of formatting hints.</span>
<span class="sd">            * pathlib.Path or None, optional: The pathlib.Path of the file if the label</span>
<span class="sd">              was read from a file; otherwise, None. Included only if `fileio` is True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            OSError: If `fileio` is True but a file could not be read.</span>

<span class="sd">            TypeError: If the source is an unrecognized type or contains an unrecognized</span>
<span class="sd">                type.</span>

<span class="sd">            VicarError: If the source violates the VICAR standard or a required VICAR</span>
<span class="sd">                parameter has an invalid value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Formatting hints can be included wherever a VICAR parameter value is</span>
<span class="sd">            specified. When defining label parameters using a list of tuples, use (name,</span>
<span class="sd">            value, hints...) instead of (name, value). Elsewhere, simply replace the value</span>
<span class="sd">            by a tuple (value, hints...).</span>

<span class="sd">            Hints can be specified using up to four items:</span>

<span class="sd">                ([`format`][[[, `name_blanks`], `val_blanks`], `sep_blanks`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+7d&quot; or &quot;%7.3f&quot;.</span>
<span class="sd">                * `name_blanks` is the number of blank characters after the name and</span>
<span class="sd">                  before the equal sign; zero by default.</span>
<span class="sd">                * `val_blanks` is the number of blank characters after the equal sign and</span>
<span class="sd">                  before the value; zero by default.</span>
<span class="sd">                * `sep_blanks` is the number of blanks after the value and before the next</span>
<span class="sd">                  label parameter or the label&#39;s end; two by default.</span>

<span class="sd">            Note the use of square brackets in the tuple expression above. If the first</span>
<span class="sd">            hint value is a string, it is interpreted as `format`; otherwise, the `format`</span>
<span class="sd">            is unspecified. After the optional format, values are interpreted as numbers</span>
<span class="sd">            of blanks. If only one int is provided, it defines `sep_blanks`, with</span>
<span class="sd">            `val_blanks` and `name_blanks` set to zero. If two trailing ints are provided,</span>
<span class="sd">            they define `val_blanks` and `sep_blanks`, with `name_blanks` set to zero.</span>

<span class="sd">            For example, if the name is &quot;TEXP&quot; and the value is 1.5, this is how hint</span>
<span class="sd">            values are interpreted::</span>

<span class="sd">                &lt;no hints&gt;        = (&quot;&quot;, 0, 0, 0)     -&gt; &quot;TEXP=1.5  &quot;</span>
<span class="sd">                &quot;%.3f&quot;            = (&quot;%.3f&quot;, 0, 0, 0) -&gt; &quot;TEXP=1.500  &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 4)       = (&quot;%.3f&quot;, 0, 0, 4) -&gt; &quot;TEXP=1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 1, 4)    = (&quot;%.3f&quot;, 0, 1, 4) -&gt; &quot;TEXP= 1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 2, 1, 4) = (&quot;%.3f&quot;, 2, 1, 4) -&gt; &quot;TEXP  = 1.500    &quot;</span>
<span class="sd">                4                 = (&quot;&quot;, 0, 0, 4)     -&gt; &quot;TEXP=1.5    &quot;</span>
<span class="sd">                (1, 4)            = (&quot;&quot;, 0, 1, 4)     -&gt; &quot;TEXP= 1.5    &quot;</span>
<span class="sd">                (2, 1, 4)         = (&quot;&quot;, 2, 1, 4)     -&gt; &quot;TEXP  = 1.5    &quot;</span>

<span class="sd">            When the parameter value is a list, it is also possible to embed formatting</span>
<span class="sd">            information on an item by item basis. Replace any item value by a tuple:</span>

<span class="sd">                (`item`[, `format`][[, `blanks_before`], `blanks_after`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+07d&quot;, &quot;%12.3e&quot; or &quot;%.4f&quot;.</span>
<span class="sd">                * `blanks_before` is the number of blanks before the value, after the left</span>
<span class="sd">                  parenthesis or comma; zero is the default.</span>
<span class="sd">                * `blanks_after` is the number of blanks after the value and before the</span>
<span class="sd">                  next comma or the right parenthesis; zero is the default.</span>

<span class="sd">            Here are some examples of a list with embedded formatting for a parameter</span>
<span class="sd">            named &quot;XY&quot; with a value [7,6]::</span>

<span class="sd">                [(7, &quot;%+02d&quot;), 6]       = [(7, &quot;%+02d&quot;, 0, 0), 6] -&gt; &quot;XY=[+07, 6]  &quot;</span>
<span class="sd">                [(7, 2), 6]             = [(7, &quot;&quot;, 0, 2), 6]      -&gt; &quot;XY=[7  , 6]  &quot;</span>
<span class="sd">                [(7, 1, 2), 6])         = [(7, &quot;&quot;, 1, 2), 6]      -&gt; &quot;XY=[ 7  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 2), 6])    = [(7, &quot;%02d&quot;, 0, 2), 6]  -&gt; &quot;XY=[07  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 1, 2), 6]) = [(7, &quot;%02d&quot;, 1, 2), 6]  -&gt; &quot;XY=[ 07  , 6]  &quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Handle files</span>
        <span class="k">if</span> <span class="n">fileio</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="p">):</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">read_label</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="n">source</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">read_label</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">read_label</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Convert to list of tuples</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>   <span class="c1"># a single tuple becomes a list of tuples</span>
        <span class="k">elif</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">v</span><span class="p">,))</span>
                      <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">_LABEL_GRAMMAR</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ParseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;VICAR parsing failure: &#39;</span> <span class="o">+</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not a recognized source type: &#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># Validate list element types</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not a valid (name, value) tuple: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">))</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not a valid (name, value, hints) tuple: &#39;</span>
                                    <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

        <span class="c1"># Extract names, values, formats and validate</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fmts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
            <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_validate_name</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_strict</span><span class="p">)</span>
            <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_interpret_value_format</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_validate_value</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_strict</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">fmts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>

        <span class="c1"># Insert required parameters if necessary</span>
        <span class="k">if</span> <span class="n">required</span><span class="p">:</span>
            <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_validate_required</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span>
                                                              <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fileio</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel._validate_name">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._validate_name">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a VicarError if this is not valid name for a VICAR label parameter.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            name (str): VICAR parameter name.</span>

<span class="sd">            strict (bool, optional): True for strict VICAR conformance, False for loose.</span>

<span class="sd">        Raises:</span>
<span class="sd">            VicarError: If this is not a valid VICAR parameter name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;VICAR name is not a string: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_NAME</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;Invalid VICAR name string: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;VICAR name exceeds 32 characters: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;VICAR name is not upper case: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>


<div class="viewcode-block" id="VicarLabel._validate_value">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._validate_value">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a VicarError if this is not valid value for a VICAR label parameter.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            value (int, float, string, or list): VICAR parameter value.</span>

<span class="sd">            name (str): Name of the VICAR parameter.</span>

<span class="sd">            strict (bool, optional): True for strict VICAR conformance, False for loose.</span>

<span class="sd">        Raises:</span>
<span class="sd">            VicarError: If this is not a valid VICAR parameter value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">isascii</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> string value is not ASCII: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> list value is empty: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="c1"># Make sure all the list elements have the same type</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                    <span class="n">type_</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                    <span class="n">type_</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">type_</span> <span class="o">=</span> <span class="nb">str</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">type_</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> item type </span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> is invalid: &#39;</span>
                                     <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">type_</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="k">return</span>

                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> items are not all of type </span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">: &#39;</span>
                                 <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> item type  </span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> is invalid: &#39;</span>
                                     <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

            <span class="k">return</span>

        <span class="n">type_</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> value type </span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> is invalid: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="VicarLabel._interpret_value_format">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._interpret_value_format">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_interpret_value_format</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the value and optional format from a (value, optional format info) tuple.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            item (int, float, string, list, or tuple):</span>
<span class="sd">                VICAR parameter value with optional formatting hints.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (any, _ValueFormat or None): A tuple containing:</span>

<span class="sd">            * int, float, string, or list: The interpreted value.</span>
<span class="sd">            * _ValueFormat or None: Formatting hints if provided; None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If this is not a tuple, the input is a standalone value with no format;</span>
        <span class="c1"># If the tuple is empty, _validate_value will raise the needed exception.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># If this parameter value is a list, interpret its values and formatting</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">listfmts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">subval</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>

                <span class="c1"># Tuple case: (value[, format][[, blanks_before], blanks_after])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">listfmts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">VicarLabel</span><span class="o">.</span><span class="n">_interpret_listfmt</span><span class="p">(</span><span class="n">subval</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subval</span><span class="p">)</span>
                    <span class="n">listfmts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">listfmts</span><span class="p">):</span>
                <span class="n">listfmts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Otherwise, the value is easy and there are no list formats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">listfmts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Interpret the rest of the tuple</span>
        <span class="n">valfmt</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_interpret_valfmt</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">listfmts</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">valfmt</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel._interpret_valfmt">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._interpret_valfmt">[docs]</a>
    <span class="k">def</span> <span class="nf">_interpret_valfmt</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">listfmts</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the _ValueFormat from a value or tuple.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            item (int, string, tuple, _ValueFormat, or None): Value format hints.</span>

<span class="sd">            listfmt (list[_ListFormat[, optional): Formats for list elements.</span>

<span class="sd">        Returns:</span>
<span class="sd">            _ValueFormat or None:</span>
<span class="sd">                Interpreted _ValueFormat; None if no formatting hints were provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">_ValueFormat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="p">:</span>    <span class="c1"># empty string, zero, None, or an empty tuple</span>
            <span class="k">if</span> <span class="n">listfmts</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">listfmts</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">listfmts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">listfmts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_ValueFormat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="n">item</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ints</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ints</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;invalid value formatting hints: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="o">*</span><span class="n">ints</span><span class="p">,</span> <span class="n">listfmts</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel._interpret_listfmt">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._interpret_listfmt">[docs]</a>
    <span class="k">def</span> <span class="nf">_interpret_listfmt</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the _ListFormat from a value or tuple.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            item (int, string, tuple, _ListFormat, or None): List element format hints.</span>

<span class="sd">        Returns:</span>
<span class="sd">            _ListFormat or None: Interpreted _ListFormat; None if there is no format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">_ListFormat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="p">:</span>    <span class="c1"># empty string, zero, None, or an empty tuple</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ListFormat</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ListFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_ListFormat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="n">item</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ints</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ints</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;invalid list formatting hints: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_ListFormat</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="o">*</span><span class="n">ints</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel._validate_required">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._validate_required">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_required</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that the required VICAR parameters are all present and valid.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            names (list[str]): List of names.</span>

<span class="sd">            vals (list[int, float, str, or list]): List of values.</span>

<span class="sd">            fmts (list[_ValueFormat or None]): List of formatting hints.</span>

<span class="sd">            append (bool, optional): True to append any missing required VICAR parameters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list, list, list): A tuple containing:</span>

<span class="sd">            * list[str]: List of names.</span>
<span class="sd">            * list[int, float, str, or list]: List of values.</span>
<span class="sd">            * list[_ValueFormat or None]: List of formatting hints.</span>

<span class="sd">        Raises:</span>
<span class="sd">            VicarError: A name or value violates the VICAR standard.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">name_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_REQUIRED</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">name_set</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_ENUMERATED_VALUES</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_ENUMERATED_VALUES</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> value: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1">; &#39;</span>
                                         <span class="sa">f</span><span class="s1">&#39;must be in </span><span class="si">{</span><span class="n">_ENUMERATED_VALUES</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_REQUIRED_INTS</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> value: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1">; &#39;</span>
                                         <span class="sa">f</span><span class="s1">&#39;must be a non-negative integer&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">append</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">fmts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;missing required VICAR parameter &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Move LBLSIZE to the front if necessary</span>
        <span class="k">if</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;LBLSIZE&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">names</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">vals</span>
                <span class="n">fmts</span> <span class="o">=</span> <span class="p">[</span><span class="n">fmt</span><span class="p">]</span> <span class="o">+</span> <span class="n">fmts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;VICAR parameter &quot;LBLSIZE&quot; must be first&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">)</span>     <span class="c1"># same list objects as input</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># Object Modification Operations</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel.append">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append the additional content to the end of this label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            source (file, pathlib.Path, str, None, dict, list, or tuple):</span>
<span class="sd">                A representation of VICAR label content:</span>

<span class="sd">                * *file*: The label string is read from the given, open file.</span>
<span class="sd">                * *pathlib.Path*: The label string is read from the referenced file.</span>
<span class="sd">                * *str*: First, a check is performed to see if it is path to an existing</span>
<span class="sd">                  file. If so, the label is read from that file; otherwise, the string is</span>
<span class="sd">                  itself interpreted as a VICAR label string.</span>
<span class="sd">                * *None*: The returned VicarLabel only contains the required parameters</span>
<span class="sd">                  with their default values.</span>
<span class="sd">                * *dict*: The label parameters are the names of the dictionary keys, given</span>
<span class="sd">                  in the order they were entered into the dictionary. Each dictionary</span>
<span class="sd">                  value is either the VICAR parameter value or a tuple(value, formatting</span>
<span class="sd">                  hints).</span>
<span class="sd">                * *list*: The label is derived from the given sequence of (name, value) or</span>
<span class="sd">                  (name, value, formatting hints) tuples.</span>
<span class="sd">                * *tuple*: A single parameter defined by (name, value) or (name, value,</span>
<span class="sd">                  formatting hints).</span>

<span class="sd">                See ``Notes`` for details about formatting hints.</span>

<span class="sd">        Raises:</span>
<span class="sd">            OSError: If the source is given as a file path that cannot be read.</span>

<span class="sd">            TypeError: If the source is an unrecognized type or contains an unrecognized</span>
<span class="sd">                type.</span>

<span class="sd">            VicarError: If the source violates the VICAR standard or a required VICAR</span>
<span class="sd">                parameter has an invalid value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Formatting hints can be included wherever a VICAR parameter value is</span>
<span class="sd">            specified. When defining label parameters using a list of tuples, use (name,</span>
<span class="sd">            value, hints...) instead of (name, value). Elsewhere, simply replace the value</span>
<span class="sd">            by a tuple (value, hints...).</span>

<span class="sd">            Hints can be specified using up to four items:</span>

<span class="sd">                ([`format`][[[, `name_blanks`], `val_blanks`], `sep_blanks`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+7d&quot; or &quot;%7.3f&quot;.</span>
<span class="sd">                * `name_blanks` is the number of blank characters after the name and</span>
<span class="sd">                  before the equal sign; zero by default.</span>
<span class="sd">                * `val_blanks` is the number of blank characters after the equal sign and</span>
<span class="sd">                  before the value; zero by default.</span>
<span class="sd">                * `sep_blanks` is the number of blanks after the value and before the next</span>
<span class="sd">                  label parameter or the label&#39;s end; two by default.</span>

<span class="sd">            Note the use of square brackets in the tuple expression above. If the first</span>
<span class="sd">            hint value is a string, it is interpreted as `format`; otherwise, the `format`</span>
<span class="sd">            is unspecified. After the optional format, values are interpreted as numbers</span>
<span class="sd">            of blanks. If only one int is provided, it defines `sep_blanks`, with</span>
<span class="sd">            `val_blanks` and `name_blanks` set to zero. If two trailing ints are provided,</span>
<span class="sd">            they define `val_blanks` and `sep_blanks`, with `name_blanks` set to zero.</span>

<span class="sd">            For example, if the name is &quot;TEXP&quot; and the value is 1.5, this is how hint</span>
<span class="sd">            values are interpreted::</span>

<span class="sd">                &lt;no hints&gt;        = (&quot;&quot;, 0, 0, 0)     -&gt; &quot;TEXP=1.5  &quot;</span>
<span class="sd">                &quot;%.3f&quot;            = (&quot;%.3f&quot;, 0, 0, 0) -&gt; &quot;TEXP=1.500  &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 4)       = (&quot;%.3f&quot;, 0, 0, 4) -&gt; &quot;TEXP=1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 1, 4)    = (&quot;%.3f&quot;, 0, 1, 4) -&gt; &quot;TEXP= 1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 2, 1, 4) = (&quot;%.3f&quot;, 2, 1, 4) -&gt; &quot;TEXP  = 1.500    &quot;</span>
<span class="sd">                4                 = (&quot;&quot;, 0, 0, 4)     -&gt; &quot;TEXP=1.5    &quot;</span>
<span class="sd">                (1, 4)            = (&quot;&quot;, 0, 1, 4)     -&gt; &quot;TEXP= 1.5    &quot;</span>
<span class="sd">                (2, 1, 4)         = (&quot;&quot;, 2, 1, 4)     -&gt; &quot;TEXP  = 1.5    &quot;</span>

<span class="sd">            When the parameter value is a list, it is also possible to embed formatting</span>
<span class="sd">            information on an item by item basis. Replace any item value by a tuple:</span>

<span class="sd">                (`item`[, `format`][[, `blanks_before`], `blanks_after`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+07d&quot;, &quot;%12.3e&quot; or &quot;%.4f&quot;.</span>
<span class="sd">                * `blanks_before` is the number of blanks before the value, after the left</span>
<span class="sd">                  parenthesis or comma; zero is the default.</span>
<span class="sd">                * `blanks_after` is the number of blanks after the value and before the</span>
<span class="sd">                  next comma or the right parenthesis; zero is the default.</span>

<span class="sd">            Here are some examples of a list with embedded formatting for a parameter</span>
<span class="sd">            named &quot;XY&quot; with a value [7,6]::</span>

<span class="sd">                [(7, &quot;%+02d&quot;), 6]       = [(7, &quot;%+02d&quot;, 0, 0), 6] -&gt; &quot;XY=[+07, 6]  &quot;</span>
<span class="sd">                [(7, 2), 6]             = [(7, &quot;&quot;, 0, 2), 6]      -&gt; &quot;XY=[7  , 6]  &quot;</span>
<span class="sd">                [(7, 1, 2), 6])         = [(7, &quot;&quot;, 1, 2), 6]      -&gt; &quot;XY=[ 7  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 2), 6])    = [(7, &quot;%02d&quot;, 0, 2), 6]  -&gt; &quot;XY=[07  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 1, 2), 6]) = [(7, &quot;%02d&quot;, 1, 2), 6]  -&gt; &quot;XY=[ 07  , 6]  &quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_source</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fileio</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">+</span> <span class="n">names</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">+</span> <span class="n">vals</span>
        <span class="n">fmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span> <span class="o">+</span> <span class="n">fmts</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel.insert">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.insert">[docs]</a>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert the given content into this label at the specified index.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            source (file, pathlib.Path, str, dict, list, or tuple):</span>
<span class="sd">                A representation of VICAR label content:</span>

<span class="sd">                * *file*: The label string is read from the given, open file.</span>
<span class="sd">                * *pathlib.Path*: The label string is read from the referenced file.</span>
<span class="sd">                * *str*: First, a check is performed to see if it is path to an existing</span>
<span class="sd">                  file. If so, the label is read from that file; otherwise, the string is</span>
<span class="sd">                  itself interpreted as a VICAR label string.</span>
<span class="sd">                * *dict*: The label parameters are the names of the dictionary keys, given</span>
<span class="sd">                  in the order they were entered into the dictionary. Each dictionary</span>
<span class="sd">                  value is either the VICAR parameter value or a tuple(value, formatting</span>
<span class="sd">                  hints).</span>
<span class="sd">                * *list*: The label is derived from the given sequence of (name, value) or</span>
<span class="sd">                  (name, value, formatting hints) tuples.</span>
<span class="sd">                * *tuple*: A single parameter defined by (name, value) or (name, value,</span>
<span class="sd">                  formatting hints).</span>

<span class="sd">                See ``Notes`` for details about formatting hints.</span>

<span class="sd">            indx (int): The integer index defining the location at which to insert the new</span>
<span class="sd">                content. If the index is non-negative, the new new content will begin at</span>
<span class="sd">                this index. If negative, the new content will end just before this index.</span>
<span class="sd">                To append, to the label, use indx = len(self).</span>

<span class="sd">        Raises:</span>
<span class="sd">            OSError: If the source is given as a file path that cannot be read.</span>

<span class="sd">            TypeError: If the source is an unrecognized type or contains an unrecognized</span>
<span class="sd">                type.</span>

<span class="sd">            VicarError: If the source violates the VICAR standard or a required VICAR</span>
<span class="sd">                parameter has an invalid value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Formatting hints can be included wherever a VICAR parameter value is</span>
<span class="sd">            specified. When defining label parameters using a list of tuples, use (name,</span>
<span class="sd">            value, hints...) instead of (name, value). Elsewhere, simply replace the value</span>
<span class="sd">            by a tuple (value, hints...).</span>

<span class="sd">            Hints can be specified using up to four items:</span>

<span class="sd">                ([`format`][[[, `name_blanks`], `val_blanks`], `sep_blanks`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+7d&quot; or &quot;%7.3f&quot;.</span>
<span class="sd">                * `name_blanks` is the number of blank characters after the name and</span>
<span class="sd">                  before the equal sign; zero by default.</span>
<span class="sd">                * `val_blanks` is the number of blank characters after the equal sign and</span>
<span class="sd">                  before the value; zero by default.</span>
<span class="sd">                * `sep_blanks` is the number of blanks after the value and before the next</span>
<span class="sd">                  label parameter or the label&#39;s end; two by default.</span>

<span class="sd">            Note the use of square brackets in the tuple expression above. If the first</span>
<span class="sd">            hint value is a string, it is interpreted as `format`; otherwise, the `format`</span>
<span class="sd">            is unspecified. After the optional format, values are interpreted as numbers</span>
<span class="sd">            of blanks. If only one int is provided, it defines `sep_blanks`, with</span>
<span class="sd">            `val_blanks` and `name_blanks` set to zero. If two trailing ints are provided,</span>
<span class="sd">            they define `val_blanks` and `sep_blanks`, with `name_blanks` set to zero.</span>

<span class="sd">            For example, if the name is &quot;TEXP&quot; and the value is 1.5, this is how hint</span>
<span class="sd">            values are interpreted::</span>

<span class="sd">                &lt;no hints&gt;        = (&quot;&quot;, 0, 0, 0)     -&gt; &quot;TEXP=1.5  &quot;</span>
<span class="sd">                &quot;%.3f&quot;            = (&quot;%.3f&quot;, 0, 0, 0) -&gt; &quot;TEXP=1.500  &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 4)       = (&quot;%.3f&quot;, 0, 0, 4) -&gt; &quot;TEXP=1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 1, 4)    = (&quot;%.3f&quot;, 0, 1, 4) -&gt; &quot;TEXP= 1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 2, 1, 4) = (&quot;%.3f&quot;, 2, 1, 4) -&gt; &quot;TEXP  = 1.500    &quot;</span>
<span class="sd">                4                 = (&quot;&quot;, 0, 0, 4)     -&gt; &quot;TEXP=1.5    &quot;</span>
<span class="sd">                (1, 4)            = (&quot;&quot;, 0, 1, 4)     -&gt; &quot;TEXP= 1.5    &quot;</span>
<span class="sd">                (2, 1, 4)         = (&quot;&quot;, 2, 1, 4)     -&gt; &quot;TEXP  = 1.5    &quot;</span>

<span class="sd">            When the parameter value is a list, it is also possible to embed formatting</span>
<span class="sd">            information on an item by item basis. Replace any item value by a tuple:</span>

<span class="sd">                (`item`[, `format`][[, `blanks_before`], `blanks_after`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+07d&quot;, &quot;%12.3e&quot; or &quot;%.4f&quot;.</span>
<span class="sd">                * `blanks_before` is the number of blanks before the value, after the left</span>
<span class="sd">                  parenthesis or comma; zero is the default.</span>
<span class="sd">                * `blanks_after` is the number of blanks after the value and before the</span>
<span class="sd">                  next comma or the right parenthesis; zero is the default.</span>

<span class="sd">            Here are some examples of a list with embedded formatting for a parameter</span>
<span class="sd">            named &quot;XY&quot; with a value [7,6]::</span>

<span class="sd">                [(7, &quot;%+02d&quot;), 6]       = [(7, &quot;%+02d&quot;, 0, 0), 6] -&gt; &quot;XY=[+07, 6]  &quot;</span>
<span class="sd">                [(7, 2), 6]             = [(7, &quot;&quot;, 0, 2), 6]      -&gt; &quot;XY=[7  , 6]  &quot;</span>
<span class="sd">                [(7, 1, 2), 6])         = [(7, &quot;&quot;, 1, 2), 6]      -&gt; &quot;XY=[ 7  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 2), 6])    = [(7, &quot;%02d&quot;, 0, 2), 6]  -&gt; &quot;XY=[07  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 1, 2), 6]) = [(7, &quot;%02d&quot;, 1, 2), 6]  -&gt; &quot;XY=[ 07  , 6]  &quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_source</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fileio</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[:</span><span class="n">indx</span><span class="p">]</span> <span class="o">+</span> <span class="n">names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">indx</span><span class="p">:]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:</span><span class="n">indx</span><span class="p">]</span> <span class="o">+</span> <span class="n">vals</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">indx</span><span class="p">:]</span>
        <span class="n">fmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[:</span><span class="n">indx</span><span class="p">]</span> <span class="o">+</span> <span class="n">fmts</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[</span><span class="n">indx</span><span class="p">:]</span>

        <span class="c1"># Make sure the required parameters are still valid</span>
        <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_validate_required</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel.reorder">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.reorder">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-order one or more specified parameters inside this object.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            *keys (list[int, name, or tuple]):</span>
<span class="sd">                Two or more indexing keys, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference parameter in a label that</span>
<span class="sd">                is re-used, such as to find the value of &quot;DAT_TIM&quot; applicable to</span>
<span class="sd">                &quot;TASK=&#39;COPY&#39;&quot; when there might be other &quot;TASK&quot; sections of the label</span>
<span class="sd">                containing other values of &quot;DAT_TIM&quot;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`. Also if an index is duplicated in the</span>
<span class="sd">                new order.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The first key is left in place, and subsequent keys are positioned after it in</span>
<span class="sd">            the order given. Use &quot;&quot; in front of the first key if you want the listed keys</span>
<span class="sd">            to be first.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">move_to_front</span> <span class="o">=</span> <span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">move_to_front</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
        <span class="n">order_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">order_set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;duplicated index in reorder&#39;</span><span class="p">)</span>

        <span class="n">before</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">move_to_front</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order_set</span><span class="p">:</span>
                    <span class="n">before</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">order</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="n">order</span>
        <span class="n">order_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order_set</span><span class="p">:</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>

        <span class="c1"># LBLSIZE restored to first</span>
        <span class="k">if</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;LBLSIZE&#39;</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
            <span class="n">formats</span> <span class="o">=</span> <span class="p">[</span><span class="n">formats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">formats</span><span class="p">)</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># Indexing Support</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel._args">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._args">[docs]</a>
    <span class="k">def</span> <span class="nf">_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;get&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The numerical index or indices of the keyed item in the VICAR label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, name, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">                Append a &quot;+&quot; to `name` to expand upon the function&#39;s behavior. With &quot;get&quot;,</span>
<span class="sd">                it returns a list of matching indices rather than a single index. With</span>
<span class="sd">                &quot;set&quot;, it will identify the index where a new parameter is to be inserted</span>
<span class="sd">                if the key is not found.</span>

<span class="sd">            mode (str, optional): One of:</span>

<span class="sd">                * &quot;get&quot;: an error will be raised if the key does not exist.</span>
<span class="sd">                * &quot;set&quot;: a single index will be returned, indicating where in the label</span>
<span class="sd">                  to insert the new parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int or list, bool): A tuple containing:</span>

<span class="sd">            * int or list[int]: The index or list of indices that identify matching</span>
<span class="sd">              parameters. If the key contains a name ending in &quot;+&quot;, this is a list</span>
<span class="sd">              starting with the &quot;nth&quot; occurrence; otherwise, it is a single int.</span>
<span class="sd">            * bool:  True if the identified parameter already exists; False if `mode` is</span>
<span class="sd">              &quot;set&quot; and the int is the location to insert a new parameter.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of  a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">},</span> <span class="s1">&#39;invalid mode: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

        <span class="c1"># Handle an integer key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="c1"># Check the key format and extract the name</span>
        <span class="n">has_plus</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_has_plus</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_remove_plus</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Handle name alone</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span> <span class="ow">and</span> <span class="n">has_plus</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">,</span> <span class="kc">False</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">has_plus</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">,</span> <span class="kc">False</span>

            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Handle (name, occurrence)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>

            <span class="c1"># Handle a reference one beyond the last valid index</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span> <span class="ow">and</span> <span class="n">indx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">,</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>    <span class="c1"># different message from indx out of range</span>

            <span class="c1"># Return if the index is in range</span>
            <span class="k">if</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">indx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;get&#39;</span> <span class="ow">and</span> <span class="n">has_plus</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="n">indx</span><span class="p">:],</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="kc">True</span>

            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="c1"># Handle (name, after_name) or (name, after_name, after_value)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">after_name</span> <span class="o">=</span> <span class="n">key</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">after_name</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">after_name</span><span class="p">)</span>

            <span class="c1"># Get the start and stop indices within this &quot;after_name&quot; section</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">after_name</span><span class="si">}</span><span class="s1"> never has value </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">k</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span> <span class="ow">and</span> <span class="n">has_plus</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">stop</span><span class="p">,</span> <span class="kc">False</span>

            <span class="c1"># Find the indices with matching names</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;get&#39;</span> <span class="ow">and</span> <span class="n">has_plus</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">stop</span><span class="p">,</span> <span class="kc">False</span>

            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;invalid key type: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>


<div class="viewcode-block" id="VicarLabel._add_plus">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._add_plus">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_plus</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a plus, if absent, at the end of the name within the indexing key.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;+&#39;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;+&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">key</span></div>


<div class="viewcode-block" id="VicarLabel._remove_plus">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._remove_plus">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_remove_plus</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a plus, if present, from the end of the name within the indexing key.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">),)</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">key</span></div>


<div class="viewcode-block" id="VicarLabel._has_plus">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._has_plus">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_has_plus</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if there is a plus at the end of the name within the indexing key.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="VicarLabel._get_name">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._get_name">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_name</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a name, if present, from the indexing key and remove any plus.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;&#39;</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># Indexing Operations</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel.arg">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.arg">[docs]</a>
    <span class="k">def</span> <span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The numerical index or indices of the keyed item in the VICAR label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, name, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">                Append a &quot;+&quot; to the name to return a list of all indices where the</span>
<span class="sd">                constraints are satisfied, starting with the first or &quot;nth&quot;.</span>

<span class="sd">            value (int, float, or string, optional):</span>
<span class="sd">                If provided, the identified parameter must equal this value. For an</span>
<span class="sd">                integer key, if the indexed parameter does not have this value, ValueError</span>
<span class="sd">                is raised. For any key involving a name, values of the named parameter</span>
<span class="sd">                that do not match `value` are skipped over until the one(s) with the</span>
<span class="sd">                correct value are found.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int or list[int]:</span>
<span class="sd">                The index or list of indices that identify matching parameters. If the key</span>
<span class="sd">                contains a name ending in &quot;+&quot;, this is a list starting with the &quot;nth&quot;</span>
<span class="sd">                occurrence; otherwise, it is a single int.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># We need to get all matches, regardless of &quot;+&quot;</span>
            <span class="n">has_plus</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_has_plus</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_add_plus</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="n">indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;get&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> never has value </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">indices</span> <span class="k">if</span> <span class="n">has_plus</span> <span class="k">else</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">index_or_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;get&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index_or_indices</span></div>


<div class="viewcode-block" id="VicarLabel.__getitem__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the value or values of the VICAR parameter defined by key, using</span>
<span class="sd">        various indexing options.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, name, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">                Append a &quot;+&quot; to the name to return a list of all values where the</span>
<span class="sd">                constraints are satisfied, starting with the first or &quot;nth&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, float, string, or list:</span>
<span class="sd">                If `key` contains a name ending in &quot;+&quot;, this is the list of values of the</span>
<span class="sd">                matching parameters, starting with the &quot;nth&quot;. Otherwise, it is the single</span>
<span class="sd">                matching value.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;get&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="VicarLabel.get">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.get">[docs]</a>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the value of the VICAR parameter defined by the given key, using</span>
<span class="sd">        various indexing options.</span>

<span class="sd">        If the key is not found, return a specified default value.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, str, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">                Append a &quot;+&quot; to the name to return a list of all values where the</span>
<span class="sd">                constraints are satisfied, starting with the first or &quot;nth&quot;.</span>

<span class="sd">            default (int, float, str, or list): The value to return if the key is not</span>
<span class="sd">                found.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int, float, str, or list:</span>
<span class="sd">                If a name is provided that ends in a plus, the returned value will be the</span>
<span class="sd">                list of all values of the selected key, or else `[default]` if the key</span>
<span class="sd">                would raise an error.</span>

<span class="sd">                Otherwise, the returned value is that of the key if present, or `default`</span>
<span class="sd">                if it is not.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">VicarError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_has_plus</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">default</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">default</span></div>


<div class="viewcode-block" id="VicarLabel.__setitem__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the value of the VICAR parameter defined by the given key; define a new</span>
<span class="sd">        parameter name and value if necessary.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, str, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">                Append a &quot;+&quot; to the name to force a new occurrence of the key to be</span>
<span class="sd">                inserted, even if the key already exists.</span>

<span class="sd">            value (int, float, string, list, or tuple):</span>
<span class="sd">                Value to assign to the indexed entry in the label.</span>

<span class="sd">                Optional formatting can be included if a user wants additional control</span>
<span class="sd">                over how this value will be formatted in the label string will be</span>
<span class="sd">                formatted, by replacing the value with a tuple (value, hints...). See</span>
<span class="sd">                ``Notes`` for details about formatting hints.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Formatting hints can be included wherever a VICAR parameter value is</span>
<span class="sd">            specified; simply replace the value by a tuple (value, hints...).</span>

<span class="sd">            Hints can be specified using up to four items:</span>

<span class="sd">                ([`format`][[[, `name_blanks`], `val_blanks`], `sep_blanks`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+7d&quot; or &quot;%7.3f&quot;.</span>
<span class="sd">                * `name_blanks` is the number of blank characters after the name and</span>
<span class="sd">                  before the equal sign; zero by default.</span>
<span class="sd">                * `val_blanks` is the number of blank characters after the equal sign and</span>
<span class="sd">                  before the value; zero by default.</span>
<span class="sd">                * `sep_blanks` is the number of blanks after the value and before the next</span>
<span class="sd">                  label parameter or the label&#39;s end; two by default.</span>

<span class="sd">            Note the use of square brackets in the tuple expression above. If the first</span>
<span class="sd">            hint value is a string, it is interpreted as `format`; otherwise, the `format`</span>
<span class="sd">            is unspecified. After the optional format, values are interpreted as numbers</span>
<span class="sd">            of blanks. If only one int is provided, it defines `sep_blanks`, with</span>
<span class="sd">            `val_blanks` and `name_blanks` set to zero. If two trailing ints are provided,</span>
<span class="sd">            they define `val_blanks` and `sep_blanks`, with `name_blanks` set to zero.</span>

<span class="sd">            For example, if the name is &quot;TEXP&quot; and the value is 1.5, this is how hint</span>
<span class="sd">            values are interpreted::</span>

<span class="sd">                &lt;no hints&gt;        = (&quot;&quot;, 0, 0, 0)     -&gt; &quot;TEXP=1.5  &quot;</span>
<span class="sd">                &quot;%.3f&quot;            = (&quot;%.3f&quot;, 0, 0, 0) -&gt; &quot;TEXP=1.500  &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 4)       = (&quot;%.3f&quot;, 0, 0, 4) -&gt; &quot;TEXP=1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 1, 4)    = (&quot;%.3f&quot;, 0, 1, 4) -&gt; &quot;TEXP= 1.500    &quot;</span>
<span class="sd">                (&quot;%.3f&quot;, 2, 1, 4) = (&quot;%.3f&quot;, 2, 1, 4) -&gt; &quot;TEXP  = 1.500    &quot;</span>
<span class="sd">                4                 = (&quot;&quot;, 0, 0, 4)     -&gt; &quot;TEXP=1.5    &quot;</span>
<span class="sd">                (1, 4)            = (&quot;&quot;, 0, 1, 4)     -&gt; &quot;TEXP= 1.5    &quot;</span>
<span class="sd">                (2, 1, 4)         = (&quot;&quot;, 2, 1, 4)     -&gt; &quot;TEXP  = 1.5    &quot;</span>

<span class="sd">            When the parameter value is a list, it is also possible to embed formatting</span>
<span class="sd">            information on an item by item basis. Replace any item value by a tuple:</span>

<span class="sd">                (`item`[, `format`][[, `blanks_before`], `blanks_after`])</span>

<span class="sd">            where:</span>

<span class="sd">                * `format` is a format string, e.g., &quot;%+07d&quot;, &quot;%12.3e&quot; or &quot;%.4f&quot;.</span>
<span class="sd">                * `blanks_before` is the number of blanks before the value, after the left</span>
<span class="sd">                  parenthesis or comma; zero is the default.</span>
<span class="sd">                * `blanks_after` is the number of blanks after the value and before the</span>
<span class="sd">                  next comma or the right parenthesis; zero is the default.</span>

<span class="sd">            Here are some examples of a list with embedded formatting for a parameter</span>
<span class="sd">            named &quot;XY&quot; with a value [7,6]::</span>

<span class="sd">                [(7, &quot;%+02d&quot;), 6]       = [(7, &quot;%+02d&quot;, 0, 0), 6] -&gt; &quot;XY=[+07, 6]  &quot;</span>
<span class="sd">                [(7, 2), 6]             = [(7, &quot;&quot;, 0, 2), 6]      -&gt; &quot;XY=[7  , 6]  &quot;</span>
<span class="sd">                [(7, 1, 2), 6])         = [(7, &quot;&quot;, 1, 2), 6]      -&gt; &quot;XY=[ 7  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 2), 6])    = [(7, &quot;%02d&quot;, 0, 2), 6]  -&gt; &quot;XY=[07  , 6]  &quot;</span>
<span class="sd">                [(7, &quot;%02d&quot;, 1, 2), 6]) = [(7, &quot;%02d&quot;, 1, 2), 6]  -&gt; &quot;XY=[ 07  , 6]  &quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Handle an integer key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

            <span class="c1"># Create a very short list of tuples and validate</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>         <span class="c1"># IndexError if out of range</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">value</span><span class="p">,))]</span>

            <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_source</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">fileio</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Default to the pre-existing format if it works</span>
            <span class="n">valfmt</span> <span class="o">=</span> <span class="n">fmts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">valfmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">valfmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">valfmt</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">valfmt</span><span class="o">.</span><span class="n">fmt</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">valfmt</span><span class="o">.</span><span class="n">fmt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;di&#39;</span><span class="p">:</span>
                                <span class="n">valfmt</span> <span class="o">=</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">valfmt</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">valfmt</span><span class="o">.</span><span class="n">fmt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;eEfFgG&#39;</span><span class="p">:</span>
                                <span class="n">valfmt</span> <span class="o">=</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">valfmt</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">else</span><span class="p">:</span>   <span class="c1"># preserve spacing only</span>
                        <span class="n">valfmt</span> <span class="o">=</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">valfmt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[])</span>

            <span class="c1"># Create new lists</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[:</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">key</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">vals</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">fmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[:</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">valfmt</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[</span><span class="n">key</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># Make sure the required parameters are still valid, then update</span>
            <span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_validate_required</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">,</span>
                                                              <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># See if this is a new or existing parameter and get its new location</span>
        <span class="n">indx</span><span class="p">,</span> <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;set&#39;</span><span class="p">)</span>

        <span class="c1"># For an update to an existing parameter, make a recursive call</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Otherwise, do the insert</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_get_name</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">value</span><span class="p">,))]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">indx</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel.__delitem__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__delitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete the value of the VICAR parameter identified by the given key.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, str, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">                Append a &quot;+&quot; to `name` to delete all of the label parameters whose names</span>
<span class="sd">                match the constraints, starting with the first or &quot;nth&quot;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section</span>
<span class="sd">                of the label defined by `after_name` and `after_value`), or if the key</span>
<span class="sd">                format is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;get&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>

        <span class="c1"># Make sure every deletion is legal</span>
        <span class="k">for</span> <span class="n">indx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_REQUIRED_NAMES</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_index</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">indx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> is a required parameter&#39;</span><span class="p">)</span>

        <span class="c1"># Make copies of lists</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="n">fmts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">)</span>

        <span class="c1"># Delete starting from end so indices don&#39;t change</span>
        <span class="k">for</span> <span class="n">indx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
            <span class="n">vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
            <span class="n">fmts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">fmts</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel.__contains__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__contains__">[docs]</a>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the given key can be used to index the VICAR label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, str, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the key is found within this label.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">indx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;get&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">VicarError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># String Methods</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel.value_str">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.value_str">[docs]</a>
    <span class="k">def</span> <span class="nf">value_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The value of the given parameter as it will appear in the label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, str, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str:</span>
<span class="sd">                The VICAR-compliant string representing the value of the selected</span>
<span class="sd">                parameter.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_scalar_str</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">fmt</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">value</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_float_str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">return</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&#39;&#39;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>

        <span class="k">def</span> <span class="nf">_float_str</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">mantissa</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">expo</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">mantissa</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>

            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">dot</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>

            <span class="k">if</span> <span class="n">tail</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sign</span> <span class="o">+</span> <span class="n">head</span> <span class="o">+</span> <span class="n">dot</span> <span class="o">+</span> <span class="n">e</span> <span class="o">+</span> <span class="n">expo</span>

            <span class="n">splitter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.*?)(00000|99999)(.*)&#39;</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sign</span> <span class="o">+</span> <span class="n">head</span> <span class="o">+</span> <span class="n">dot</span> <span class="o">+</span> <span class="n">before</span> <span class="o">+</span> <span class="n">e</span> <span class="o">+</span> <span class="n">expo</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">before</span><span class="p">:</span>          <span class="c1"># &quot;1.99999&quot; -&gt; &quot;2.&quot;</span>
                <span class="n">head</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sign</span> <span class="o">+</span> <span class="n">head</span> <span class="o">+</span> <span class="n">dot</span> <span class="o">+</span> <span class="n">e</span> <span class="o">+</span> <span class="n">expo</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_float_str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># Increment tail but preserve leading zeros: &quot;1.0299999&quot; -&gt; &quot;1.03&quot;</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">before</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;d&#39;</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">before</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sign</span> <span class="o">+</span> <span class="n">head</span> <span class="o">+</span> <span class="n">dot</span> <span class="o">+</span> <span class="n">tail</span> <span class="o">+</span> <span class="n">e</span> <span class="o">+</span> <span class="n">expo</span>

        <span class="c1">#### Active code...</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_remove_plus</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
        <span class="n">valfmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">valfmt</span><span class="o">.</span><span class="n">val_blanks</span> <span class="o">*</span> <span class="s1">&#39; &#39;</span><span class="p">]</span>
        <span class="n">sep_blanks</span> <span class="o">=</span> <span class="n">valfmt</span><span class="o">.</span><span class="n">sep_blanks</span>

        <span class="c1"># Handle LBLSIZE, which always occupies 16 blanks, left-justified</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;LBLSIZE&#39;</span><span class="p">:</span>
            <span class="n">valstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valstr</span><span class="p">)</span>
            <span class="n">sep_blanks</span> <span class="o">=</span> <span class="n">_LBLSIZE_WIDTH</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">valstr</span><span class="p">)</span>

        <span class="c1"># Handle a list</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span>
            <span class="n">listfmts</span> <span class="o">=</span> <span class="n">valfmt</span><span class="o">.</span><span class="n">listfmts</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">_ListFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">listfmts</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">blanks_before</span> <span class="o">*</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">_scalar_str</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">fmt</span><span class="p">),</span>
                               <span class="n">f</span><span class="o">.</span><span class="n">blanks_after</span> <span class="o">*</span> <span class="s1">&#39; &#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_scalar_str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

            <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;)&#39;</span>

        <span class="c1"># Handle a scalar</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_scalar_str</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">valfmt</span><span class="o">.</span><span class="n">fmt</span><span class="p">))</span>

        <span class="c1"># Append right padding</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep_blanks</span> <span class="o">*</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel.name_value_str">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.name_value_str">[docs]</a>
    <span class="k">def</span> <span class="nf">name_value_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert one entry in the dictionary to a string of the form &quot;NAME=VALUE&quot;.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (int, str, or tuple): The indexing key, interpreted as follows:</span>

<span class="sd">                * *int* = `n`: The &quot;nth&quot; parameter in the label. `n` can be positive or</span>
<span class="sd">                  negative.</span>
<span class="sd">                * *str* = `name`: The first occurrence in the label of a parameter with</span>
<span class="sd">                  this name.</span>
<span class="sd">                * (*str*, *int*) = (`name`, `n`): The &quot;nth&quot; occurrence in the label of a</span>
<span class="sd">                  parameter with this name. `n` can be positive or negative.</span>
<span class="sd">                * (*str*, *str*) = (`name`, `after`): The first occurrence of parameter</span>
<span class="sd">                  `name` after the first occurrence of parameter `after` and before the</span>
<span class="sd">                  second occurrence of `after`.</span>
<span class="sd">                * (*str*, *str*, *any*) = (`name`, `after`, `value`): The first occurrence</span>
<span class="sd">                  of parameter `name` after the first location where `after` equals</span>
<span class="sd">                  `value` and before the next occurrence of `after`.</span>

<span class="sd">                The last two options make it easy to reference a VICAR label parameter</span>
<span class="sd">                that is repeated. For example, label[&quot;DAT_TIM&quot;, &quot;TASK&quot;, &quot;COPY&quot;] uniquely</span>
<span class="sd">                identifies the occurrence of &quot;DAT_TIM&quot; applicable to &quot;TASK=&#39;COPY&#39;&quot; when</span>
<span class="sd">                there might be other &quot;TASK&quot; sections of the label containing other values</span>
<span class="sd">                of &quot;DAT_TIM&quot;.</span>

<span class="sd">            pad (bool, optional):</span>
<span class="sd">                If True, the returned string will end with at least one blank character.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A &quot;NAME=VALUE&quot; string compliant with the VICAR standard.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If any numeric component of the key is out of range.</span>

<span class="sd">            KeyError: If the parameter name is not present in the label (or the section of</span>
<span class="sd">                the label defined by `after_name` and `after_value`), or if the key format</span>
<span class="sd">                is unrecognized.</span>

<span class="sd">            TypeError: If the key is not a recognized type or contains a component that is</span>
<span class="sd">                not of a recognized type.</span>

<span class="sd">            ValueError: If no identified parameter equals `value` or if no occurrence of</span>
<span class="sd">                `after_name` equals `after_value`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="o">.</span><span class="n">_remove_plus</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">valfmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_ValueFormat</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">valstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">valfmt</span><span class="o">.</span><span class="n">name_blanks</span> <span class="o">*</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">valstr</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">pad</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">valstr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel._prep_for_export">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._prep_for_export">[docs]</a>
    <span class="k">def</span> <span class="nf">_prep_for_export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the label&#39;s LBLSIZE and EOL values in preparation for export.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            resize (bool, optional):</span>
<span class="sd">                If True, LBLSIZE will be modified to accommodate the new content.</span>
<span class="sd">                Otherwise, the current value of LBLSIZE will be preserved and any overflow</span>
<span class="sd">                content will be placed into an end-of-file (&quot;EOL&quot;) label. In this case, a</span>
<span class="sd">                second LBLSIZE parameter will mark the starting location of this label.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="n">lblsize</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">]</span>
        <span class="n">recsize</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;RECSIZE&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lblsize</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">lblsize</span> <span class="o">%</span> <span class="n">recsize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">resize</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n123_from_nbls</span><span class="p">()</span>      <span class="c1"># fix N1, N2, N3</span>

        <span class="c1"># Remove any extra LBLSIZE values</span>
        <span class="k">while</span> <span class="p">(</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[(</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># Track the lengths of the &quot;name=value&quot; pairs</span>
        <span class="n">eol</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">):</span>
            <span class="n">name_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_value_str</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">newlen</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resize</span> <span class="ow">and</span> <span class="n">newlen</span> <span class="o">&gt;</span> <span class="n">lblsize</span><span class="p">:</span>
                <span class="n">eol</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">label_count</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>     <span class="c1"># number of parameters in the first VICAR label</span>
                <span class="k">break</span>

            <span class="n">length</span> <span class="o">=</span> <span class="n">newlen</span>

        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;EOL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eol</span>

        <span class="k">if</span> <span class="n">eol</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">label_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">):</span>
                <span class="n">name_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_value_str</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">length</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_value</span><span class="p">)</span>

            <span class="n">eol_lblsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;LBLSIZE=&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">_LBLSIZE_WIDTH</span> <span class="o">+</span> <span class="n">length</span>
            <span class="n">eol_recs</span> <span class="o">=</span> <span class="p">(</span><span class="n">eol_lblsize</span> <span class="o">+</span> <span class="n">recsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">recsize</span>
            <span class="n">eol_lblsize</span> <span class="o">=</span> <span class="n">eol_recs</span> <span class="o">*</span> <span class="n">recsize</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LBLSIZE+&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eol_lblsize</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">label_count</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">resize</span><span class="p">:</span>
            <span class="n">nrecs</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">recsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">recsize</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nrecs</span> <span class="o">*</span> <span class="n">recsize</span></div>


<div class="viewcode-block" id="VicarLabel.export">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.export">[docs]</a>
    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Export this VicarLabel to text strings.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            resize (bool, optional):</span>
<span class="sd">                If True, LBLSIZE will be modified to accommodate the new content.</span>
<span class="sd">                Otherwise, the current value of LBLSIZE will be preserved and any overflow</span>
<span class="sd">                content will be placed into an end-of-file label.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str, str): A tuple containing:</span>

<span class="sd">            * str: The VICAR label at the top of the file, as constrained by the internal</span>
<span class="sd">              values of LBLSIZE and RECSIZE. The string is padded with null characters to</span>
<span class="sd">              the full length specified by LBLSIZE.</span>
<span class="sd">            * str: The VICAR end-of-file label; empty if all the label content fits within</span>
<span class="sd">              the specified LBLSIZE.</span>

<span class="sd">        Note:</span>
<span class="sd">            The returned strings must be encoded as &quot;latin8&quot; bytes before writing them</span>
<span class="sd">            into a data file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_prep_for_export</span><span class="p">(</span><span class="n">resize</span><span class="o">=</span><span class="n">resize</span><span class="p">)</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;LBLSIZE&#39;</span><span class="p">:</span>
                <span class="n">k_eol</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_value_str</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">k_eol</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pairs</span><span class="p">[:</span><span class="n">k_eol</span><span class="p">]),</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">k_eol</span><span class="p">:])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pairs</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lblsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span> <span class="o">+</span> <span class="p">(</span><span class="n">lblsize</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">))</span> <span class="o">*</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="VicarLabel.as_string">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.as_string">[docs]</a>
    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The content of this label as a string.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            start (int, optional):</span>
<span class="sd">                Index or key of the first parameter to include in the string.</span>

<span class="sd">            stop (int, optional):</span>
<span class="sd">                Index or key just after the last parameter to include in the string.</span>

<span class="sd">            sep (str, optional):</span>
<span class="sd">                Optional characters to insert before a second LBLSIZE. For example, use</span>
<span class="sd">                &quot;\\n&quot; to create a string with a line break before any extension label.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A label string compliant with the VICAR standard.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">stop</span><span class="p">))</span>

        <span class="n">label</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="n">name_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_value_str</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Add optional separator before a second LBLSIZE</span>
            <span class="k">if</span> <span class="n">sep</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;LBLSIZE&#39;</span><span class="p">:</span>
                <span class="n">label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>

            <span class="n">label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># Iterators</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel.__iter__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__iter__">[docs]</a>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over the unique names or (name, occurrence) pairs in the label.</span>

<span class="sd">        Returns:</span>
<span class="sd">            iterator:</span>
<span class="sd">                An iterator over the parameter keys within this label, in order. The key</span>
<span class="sd">                is the parameter name if it is unique or (name, occurrence number)</span>
<span class="sd">                otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="VicarLabel.__next__">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.__next__">[docs]</a>
    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>


<div class="viewcode-block" id="VicarLabel.names">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.names">[docs]</a>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over the names in this label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pattern (str or re.Pattern, optional):</span>
<span class="sd">                Regular expression that can be used to filter the label parameter names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: The list of the matching parameter names within this label, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>        <span class="c1"># return a copy</span></div>


<div class="viewcode-block" id="VicarLabel.keys">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.keys">[docs]</a>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over the keys of the parameters within this label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pattern (str or re.Pattern, optional):</span>
<span class="sd">                Regular expression that can be used to filter the label parameter names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list:</span>
<span class="sd">                The list of the parameter keys within this label, in order. The key is the</span>
<span class="sd">                parameter name if it is unique or (name, occurrence number) otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique_keys</span><span class="p">)</span>  <span class="c1"># return a copy</span></div>


<div class="viewcode-block" id="VicarLabel.values">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.values">[docs]</a>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over the values in this VicarLabel.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pattern (str or re.Pattern, optional):</span>
<span class="sd">                Regular expression that can be used to filter the label parameter names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            iterator: The values of the matching parameters within this label, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel.items">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.items">[docs]</a>
    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over the (key, value) pairs in this label.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pattern (str or re.Pattern, optional):</span>
<span class="sd">                Regular expression that can be used to filter the label parameter names.</span>

<span class="sd">            unique (bool, optional):</span>
<span class="sd">                True to return unique keys, in which non-unique names are replaced by</span>
<span class="sd">                tuples (name, occurrence). If False, all keys are name strings, and a name</span>
<span class="sd">                may appear multiple times.</span>

<span class="sd">        Returns:</span>
<span class="sd">            iterator:</span>
<span class="sd">                The tuples (name, value) of the matching parameter names within this</span>
<span class="sd">                label, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique_keys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique_keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="VicarLabel.args">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.args">[docs]</a>
    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over the numerical indices of the keywords.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            pattern (str or re.Pattern, optional):</span>
<span class="sd">                Regular expression that can be used to filter the label parameter names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            iterator:</span>
<span class="sd">                The indices of the matching parameter names within this label, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

        <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_len</span><span class="p">)</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># File I/O</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel.read_label">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.read_label">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read_label</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">_extra</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The VICAR label string from the specified data file.</span>

<span class="sd">        If an EOL label is present, the content of the extension label is appended to the</span>
<span class="sd">        returned string. This can be recognized by a second occurrence of the LBLSIZE</span>
<span class="sd">        parameter.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            source (str, pathlib.Path, or file):</span>
<span class="sd">                A path to a VICAR data file or else a file object already opened for</span>
<span class="sd">                binary read.</span>

<span class="sd">            _extra (bool, optional):</span>
<span class="sd">                True to return any extraneous bytes from the end of the data file in</span>
<span class="sd">                addition to the label.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str or (str, bytes): A string or a tuple containing:</span>

<span class="sd">            * str: The VICAR label as a character string, with the EOL label appended if</span>
<span class="sd">              one is present. The EOL label can be recognized by the presence of a second</span>
<span class="sd">              LBLSIZE parameter.</span>
<span class="sd">            * bytes: A bytes object containing any extraneous characters at the end of the</span>
<span class="sd">              file, included if `_extra` is True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            OSError: If the referenced file could not be read.</span>

<span class="sd">            VicarError: If the referenced file does not conform to the VICAR standard.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">source</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>
            <span class="n">close_when_done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">close_when_done</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Read the beginning of the VICAR file to get the label size</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">snippet</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;latin8&#39;</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">_LBLSIZE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">snippet</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>       <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;Missing LBLSIZE keyword in file &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">filepath</span><span class="p">))</span>

            <span class="n">lblsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Read the top VICAR label</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">lblsize</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;latin8&#39;</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Parse</span>
            <span class="n">ldict</span> <span class="o">=</span> <span class="n">VicarLabel</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Figure out the distance to the EOL label</span>
            <span class="n">recsize</span> <span class="o">=</span> <span class="n">ldict</span><span class="p">[</span><span class="s1">&#39;RECSIZE&#39;</span><span class="p">]</span>
            <span class="n">nlb</span> <span class="o">=</span> <span class="n">ldict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;NLB&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># N2*N3 is simpler but there are files where these values aren&#39;t right</span>
            <span class="k">if</span> <span class="n">ldict</span><span class="p">[</span><span class="s1">&#39;ORG&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;BIP&#39;</span><span class="p">:</span>           <span class="c1"># pragma: no cover</span>
                <span class="n">data_recs</span> <span class="o">=</span> <span class="n">ldict</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ldict</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_recs</span> <span class="o">=</span> <span class="n">ldict</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ldict</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">]</span>
            <span class="n">skip</span> <span class="o">=</span> <span class="n">lblsize</span> <span class="o">+</span> <span class="n">recsize</span> <span class="o">*</span> <span class="p">(</span><span class="n">nlb</span> <span class="o">+</span> <span class="n">data_recs</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">skip</span><span class="p">)</span>

            <span class="c1"># Try to read the EOF label</span>
            <span class="n">snippet</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;latin8&#39;</span><span class="p">))</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">_LBLSIZE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">snippet</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">eolsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">skip</span><span class="p">)</span>
                <span class="n">eol</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">eolsize</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;latin8&#39;</span><span class="p">)</span>
                <span class="n">eol</span> <span class="o">=</span> <span class="n">eol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">):</span>     <span class="c1"># pragma: no cover</span>
                    <span class="n">label</span> <span class="o">+=</span> <span class="s1">&#39;  &#39;</span>

                <span class="n">label</span> <span class="o">+=</span> <span class="n">eol</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">skip</span><span class="p">)</span>

            <span class="c1"># Check for extraneous bytes</span>
            <span class="k">if</span> <span class="n">_extra</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

            <span class="k">return</span> <span class="n">label</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">close_when_done</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="VicarLabel.from_file">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.from_file">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A new VicarLabel object derived from the given VICAR data file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            filepath (str or pathlib.Path): Path to a VICAR data file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            VicarLabel: VicarLabel object read from file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">VicarLabel</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">filepath</span><span class="p">)</span></div>


<div class="viewcode-block" id="VicarLabel.write_label">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel.write_label">[docs]</a>
    <span class="k">def</span> <span class="nf">write_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace the label in the selected VICAR file with this label content.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            filepath (str or pathlib.Path, optional):</span>
<span class="sd">                Optional path of the existing file to write. If not provided, the value of</span>
<span class="sd">                this object&#39;s filepath attribute is used.</span>

<span class="sd">        Note:</span>
<span class="sd">            This method modifies the file without first creating a backup, so it should be</span>
<span class="sd">            used with caution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filepath</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filepath</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;file path is missing&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finish_update</span><span class="p">()</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;r+b&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>

            <span class="n">snippet</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;latin8&#39;</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">_LBLSIZE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">snippet</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>       <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="n">VicarError</span><span class="p">(</span><span class="s1">&#39;Missing LBLSIZE keyword in file &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filepath</span><span class="p">))</span>

            <span class="n">lblsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LBLSIZE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lblsize</span>

            <span class="c1"># Update the header</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">resize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;latin8&#39;</span><span class="p">))</span>

            <span class="c1"># Update the EOL label, possibly truncating the file</span>
            <span class="n">recsize</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;RECSIZE&#39;</span><span class="p">]</span>
            <span class="n">nlb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;NLB&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">]</span>
            <span class="n">n3</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">]</span>
            <span class="n">skip</span> <span class="o">=</span> <span class="n">lblsize</span> <span class="o">+</span> <span class="n">recsize</span> <span class="o">*</span> <span class="p">(</span><span class="n">nlb</span> <span class="o">+</span> <span class="n">n2</span><span class="o">*</span><span class="n">n3</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">skip</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;latin8&#39;</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span></div>


    <span class="c1">######################################################################################</span>
    <span class="c1"># Other Utilities</span>
    <span class="c1">######################################################################################</span>

<div class="viewcode-block" id="VicarLabel._set_n321">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._set_n321">[docs]</a>
    <span class="k">def</span> <span class="nf">_set_n321</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the values of N1, N2, N3.</span>

<span class="sd">        NB, NL, and NS will be derived from these, depending on the ORG.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            n3 (int): Value for N3.</span>
<span class="sd">            n2 (int): Value for N2.</span>
<span class="sd">            n1 (int): Value for N1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nbls_from_n123</span><span class="p">()</span></div>


<div class="viewcode-block" id="VicarLabel._set_nbls">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._set_nbls">[docs]</a>
    <span class="k">def</span> <span class="nf">_set_nbls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">nl</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the values of NB, NL, NS.</span>

<span class="sd">        N1, N2, and N3 will be derived from these, depending on the ORG.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            nb (int): Value for NB.</span>
<span class="sd">            nl (int): Value for NL.</span>
<span class="sd">            ns (int): Value for NS.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">nl</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n123_from_nbls</span><span class="p">()</span></div>


<div class="viewcode-block" id="VicarLabel._n123_from_nbls">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._n123_from_nbls">[docs]</a>
    <span class="k">def</span> <span class="nf">_n123_from_nbls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill in the N1, N2, N3 parameters given values of NB, NL, NS and ORG.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ORG&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;BSQ&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ORG&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;BIL&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># == &#39;BIP&#39;</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="VicarLabel._nbls_from_n123">
<a class="viewcode-back" href="../../module.html#vicar.VicarLabel._nbls_from_n123">[docs]</a>
    <span class="k">def</span> <span class="nf">_nbls_from_n123</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill in the NB, NL, NS parameters given values of N1, N2, N3 and ORG.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ORG&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;BSQ&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;ORG&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;BIL&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># == &#39;BIP&#39;</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NB&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NS&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;NL&#39;</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N2&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;N3&#39;</span><span class="p">])</span></div>
</div>


<span class="c1">##########################################################################################</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, PDS Ring-Moon Systems Node.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>